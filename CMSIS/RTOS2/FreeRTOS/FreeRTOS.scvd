<?xml version="1.0" encoding="utf-8"?>
<component_viewer schemaVersion="0.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="Component_Viewer.xsd">
  <component name="CMSIS-FreeRTOS" version="11.2.0"/>

  <typedefs>
    <typedef name="ListItem_t" size="20" info="List object definition (list.h)">
      <!-- Excluded integrity check value -->
      <member name="xItemValue"  type="uint32_t"    offset="0"/>
      <member name="pxNext"      type="*ListItem_t" offset="4"/>
      <member name="pxPrevious"  type="*ListItem_t" offset="8"/>
      <member name="pvOwner"     type="uint32_t"    offset="12"/>
      <member name="pvContainer" type="uint32_t"    offset="16"/>
      <!-- Excluded integrity check value -->
    </typedef>

    <typedef name="List_t" size="20" info="List definition (list.h)">
      <!-- Excluded integrity check value -->
      <member name="uxNumberOfItems" type="uint32_t"    offset="0"/>
      <member name="pxIndex"         type="*ListItem_t" offset="4"/>
      <!-- Inlined "MiniListItem_t" structure -->
      <member name="xListEnd_xItemValue" type="*ListItem_t" offset="8+0"/>
      <member name="xListEnd_pxNext"     type="*ListItem_t" offset="8+4"/>
      <member name="xListEnd_pxPrevious" type="*ListItem_t" offset="8+8"/>
      <!-- Excluded integrity check value -->
    </typedef>

    <typedef name="Queue_t" size="76" info="Queue definition (queue.c)">
      <member name="pcHead"    type="uint32_t"    offset="0" info="(type is *int32_t), also uxQueueType"/>
      <member name="pcTail"    type="uint32_t"    offset="4" info="(type is *int32_t), also pxMutexHolder"/>
      <member name="pcWriteTo" type="uint32_t"    offset="8" info="(type is *int32_t)"/>
      <!-- Union "u" -->
      <member name="u_pcReadFrom"           type="uint32_t"  offset="12" info="(type is *int32_t)"/>
      <member name="u_uxRecursiveCallCount" type="uint32_t"  offset="12"/>
      <!-- Inlined "List_t" structure -->
      <member name="xTasksWaitingToSend_uxNumberOfItems"     type="uint32_t"    offset="16+0"/>
      <member name="xTasksWaitingToSend_pxIndex"             type="*ListItem_t" offset="16+4"/>
      <member name="xTasksWaitingToSend_xListEnd_xItemValue" type="*ListItem_t" offset="16+8"/>
      <member name="xTasksWaitingToSend_xListEnd_pxNext"     type="*ListItem_t" offset="16+12"/>
      <member name="xTasksWaitingToSend_xListEnd_pxPrevious" type="*ListItem_t" offset="16+16"/>
      <!-- Inlined "List_t" structure -->
      <member name="xTasksWaitingToReceive_uxNumberOfItems"     type="uint32_t"    offset="36+0"/>
      <member name="xTasksWaitingToReceive_pxIndex"             type="*ListItem_t" offset="36+4"/>
      <member name="xTasksWaitingToReceive_xListEnd_xItemValue" type="*ListItem_t" offset="36+8"/>
      <member name="xTasksWaitingToReceive_xListEnd_pxNext"     type="*ListItem_t" offset="36+12"/>
      <member name="xTasksWaitingToReceive_xListEnd_pxPrevious" type="*ListItem_t" offset="36+16"/>

      <member name="uxMessagesWaiting" type="uint32_t" offset="56"/>
      <member name="uxLength"          type="uint32_t" offset="60"/>
      <member name="uxItemSize"        type="uint32_t" offset="64"/>
      <member name="cRxLock"           type="int32_t"  offset="68"/>
      <member name="cTxLock"           type="int32_t"  offset="72"/>

      <!-- #if((configSUPPORT_STATIC_ALLOCATION == 1) && (configSUPPORT_DYNAMIC_ALLOCATION == 1)) -->
      <!-- <member name="ucStaticallyAllocated" type="uint8_t"  offset="76"/> -->
      <!-- #endif -->
      <!-- #if (configUSE_QUEUE_SETS == 1) -->
      <!-- <member name="pxQueueSetContainer"   type="uint32_t" offset="80"/> -->
      <!-- #endif -->
      <!-- #if (configUSE_TRACE_FACILITY == 1) -->
      <!-- <member name="uxQueueNumber" type="uint32_t" offset="84"/> -->
      <!-- <member name="uxQueueType"   type="uint8_t"  offset="88"/> -->
      <!-- #endif -->
      
      <var name="Name"  type="uint8_t" size="64" info="Queue name (ASCII)"/>
      <var name="Type"  type="uint32_t" info="Queue type (Queue:0, Mutex:1, Semaphore:2)"/>
    </typedef>

    <typedef name="QueueRegistryItem_t" size="8">
      <member name="pcQueueName" type="uint32_t" offset="0" info="(type is const char *)"/>
      <member name="xHandle"     type="uint32_t" offset="4" info="(type is QueueHandle_t)"/>
    </typedef>


    <typedef name="TCB_t" size="128" info="Task Control Block definition (tasks.c)">
      <member name="pxTopOfStack" type="uint32_t" offset="0" info="Location of the last item placed on the tasks stack (type is StackType_t *)"/>
      <!-- Inlined "ListItem_t" structure -->
      <member name="xStateListItem_xItemValue"  type="uint32_t"    offset="4+0"  info=""/>
      <member name="xStateListItem_pxNext"      type="*ListItem_t" offset="4+4"  info=""/>
      <member name="xStateListItem_pxPrevious"  type="*ListItem_t" offset="4+8"  info=""/>
      <member name="xStateListItem_pvOwner"     type="uint32_t"    offset="4+12" info=""/>
      <member name="xStateListItem_pvContainer" type="uint32_t"    offset="4+16" info=""/>
      <!-- Inlined "ListItem_t" structure -->
      <member name="xEventListItem_xItemValue"  type="uint32_t"    offset="24+0"  info=""/>
      <member name="xEventListItem_pxNext"      type="*ListItem_t" offset="24+4"  info=""/>
      <member name="xEventListItem_pxPrevious"  type="*ListItem_t" offset="24+8"  info=""/>
      <member name="xEventListItem_pvOwner"     type="uint32_t"    offset="24+12" info=""/>
      <member name="xEventListItem_pvContainer" type="uint32_t"    offset="24+16" info=""/>

      <member name="uxPriority" type="uint32_t"           offset="44" info=""/>
      <member name="pxStack"    type="uint32_t"           offset="48" info=""/>
      <member name="pcTaskName" type="uint8_t"  size="16" offset="52" info="Task name (size is defined by configMAX_TASK_NAME_LEN)"/>

      <!-- #if(portCRITICAL_NESTING_IN_TCB == 1) -->
      <!-- <member name="uxCriticalNesting" type="uint32_t" info=""/> -->
      <!-- #endif -->

      <!-- #if(configUSE_TRACE_FACILITY == 1) -->
      <!-- <member name="uxTCBNumber"  type="uint32_t" offset="68" info=""/> -->
      <!-- <member name="uxTaskNumber" type="uint32_t" offset="72" info=""/> -->
      <!-- #endif -->

      <!-- #if(configUSE_MUTEXES == 1) -->
      <!-- <member name="uxBasePriority" type="uint32_t" offset="74" info=""/> -->
      <!-- <member name="uxMutexesHeld"  type="uint32_t" offset="78" info=""/> -->
      <!-- #endif -->

      <!-- #if(configUSE_APPLICATION_TASK_TAG == 1) -->
      <!-- <member name="pxTaskTag"  type="uint32_t" info="(type is TaskHookFunction_t)"/> -->
      <!-- #endif -->

      <!-- #if(configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0) -->
      <!-- <member name="pvThreadLocalStoragePointers" type="uint32_t" size="10" info="(type is void *)"/> --> <!-- size="configNUM_THREAD_LOCAL_STORAGE_POINTERS" (size is defined by configNUM_THREAD_LOCAL_STORAGE_POINTERS) -->
      <!-- #endif -->

      <!-- #if(configGENERATE_RUN_TIME_STATS == 1) -->
      <!-- <member name="ulRunTimeCounter" type="uint32_t" info=""/> -->
      <!-- #endif -->

      <!-- #if(configUSE_TASK_NOTIFICATIONS == 1) -->
      <!-- <member name="ulNotifiedValue" type="uint32_t" offset="82" info=""/> -->
      <!-- <member name="ucNotifyState"   type="uint8_t"  offset="86" info=""/> -->
      <!-- #endif -->

      <!-- #if(tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0) -->
      <!-- <member name="ucStaticallyAllocated" type="uint8_t" offset="90" info=""/> -->
      <!-- endif -->

      <!-- #if(INCLUDE_xTaskAbortDelay == 1) -->
      <!-- <member name="ucDelayAborted" type="uint32_t" info=""/> -->
      <!-- #endif -->
      
      <!-- #if( configUSE_POSIX_ERRNO == 1 ) -->
      <!-- <member name="iTaskErrno" type="int32_t" info=""/> -->
      <!-- #endif -->

      <var name="StackAvailable" type="uint32_t" info="Available stack (unused): current (in bytes)"/>
      <var name="StackOverflow"  type="uint32_t" info="Stack overflow flag"/>
      <var name="WaitType"       type="uint32_t" info="Waiting object type  (Queue:0, Mutex:1, Semaphore:2, EventGroup:3)"/>
      <var name="WaitValue"      type="uint32_t" info="Waiting object value (Index in Queue_CB or event group flags)"/>
    </typedef>

    <typedef name="Timer_t" size="36" info="Timer Control Block definition (timers.c)">
      <member name="pcTimerName" type="uint32_t" offset="0" info="Timer name (type is const char *)."/>
      <!-- Inlined "ListItem_t" structure -->
      <member name="xTimerListItem_xItemValue"  type="uint32_t"    offset="4+0"  info=""/>
      <member name="xTimerListItem_pxNext"      type="*ListItem_t" offset="4+4"  info=""/>
      <member name="xTimerListItem_pxPrevious"  type="*ListItem_t" offset="4+8"  info=""/>
      <member name="xTimerListItem_pvOwner"     type="uint32_t"    offset="4+12" info=""/>
      <member name="xTimerListItem_pvContainer" type="uint32_t"    offset="4+16" info=""/>

      <member name="xTimerPeriodInTicks" type="uint32_t" offset="24" info="How quickly and often the timer expires."/>
      <member name="pvTimerID"           type="uint32_t" offset="28" info="An ID to identify the timer (type is void *)."/>
      <member name="pxCallbackFunction"  type="uint32_t" offset="32" info="The function that will be called when the timer expires."/>

      <!-- #if(configUSE_TRACE_FACILITY == 1) -->
      <!-- <member name="uxTimerNumber" type="uint32_t" offset="36" info="An ID assigned by trace tools such as FreeRTOS+Trace."/> -->
      <!-- #endif -->

      <!-- <member name="ucStatus"      type="uint8_t"  offset="40" info="Status bitmask (timer active/inactive, static allocation)."/> -->

      <var name="Name" type="uint8_t" info="Timer name string" size="64"/>
    </typedef>

  </typedefs>

  <objects>
    <object name="FreeRTOS Object">
      <var name="i"  type="uint32_t" value="0"/>
      <var name="j"  type="uint32_t" value="0"/>
      <var name="n"  type="uint32_t" value="0"/>
      <var name="sp" type="uint32_t" value="0"/>

      <var name="CV_En" type="uint8_t" value="0"/>

      <var name="Queue_REG_Size"       type="uint32_t" value="0"/>
      <var name="Queue_REG_Queues"     type="uint32_t" value="0"/>
      <var name="Queue_REG_Mutexes"    type="uint32_t" value="0"/>
      <var name="Queue_REG_Semaphores" type="uint32_t" value="0"/>

      <read name="xSchedulerRunning"      type="uint32_t" symbol="tasks.c/xSchedulerRunning"/>
      <read name="xYieldPending"          type="uint32_t" symbol="tasks.c/xYieldPendings"/>
      <read name="xTickCount"             type="uint32_t" symbol="tasks.c/xTickCount"/>
      <read name="xNumOfOverflows"        type="uint32_t" symbol="tasks.c/xNumOfOverflows"/>
      <read name="xPendedTicks"           type="uint32_t" symbol="tasks.c/xPendedTicks"/>
      <read name="pxCurrentTCB"           type="uint32_t" symbol="tasks.c/pxCurrentTCB"/>
      <read name="uxCurrentNumberOfTasks" type="uint32_t" symbol="tasks.c/uxCurrentNumberOfTasks"/>

      <read name="xIdleTaskHandle"        type="uint32_t" symbol="tasks.c/xIdleTaskHandles"/>
      <read name="xTimerTaskHandle"       type="uint32_t" symbol="timers.c/xTimerTaskHandle"/>
      <read name="xTimerQueue"            type="uint32_t" symbol="timers.c/xTimerQueue"/>

      <!-- Try to determine if memory is initialized -->
      <calc cond="((xSchedulerRunning &lt; 2) &amp;&amp; (xYieldPending &lt; 2))">
        CV_En = 1;
      </calc>

      <!-- Running Task -->
      <read cond="CV_En" name="Running_TCB" type="TCB_t" offset="pxCurrentTCB"/>

      <calc cond="CV_En">
        sp = __GetRegVal ("PSP");

        Running_TCB.StackAvailable = sp - Running_TCB.pxStack;
        Running_TCB.StackOverflow  = (sp &lt;= Running_TCB.pxStack);
      </calc>


      <!-- Ready Tasks -->
      <readlist cond="CV_En" name="pxReadyTasksLists" type="List_t" symbol="tasks.c/pxReadyTasksLists" count="__size_of(&quot;tasks.c/pxReadyTasksLists&quot;)" init="1"/>
      
      <!-- Read ready lists for each priority -->
      <list name="i" start="0" limit="pxReadyTasksLists._count">
        <!-- Determine address of first item in list, read current item and determine address of next item in list -->
        <calc> n = pxReadyTasksLists[i].xListEnd_pxNext; </calc>

        <list name="j" start="0" limit="pxReadyTasksLists[i].uxNumberOfItems">
          <readlist name="pxReadyTasks" type="ListItem_t" offset="n" count="1"/>

          <calc> n = pxReadyTasks[pxReadyTasks._count-1].pxNext; </calc>
        </list>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="pxReadyTasks._count">
        <readlist name="Ready_TCB" type="TCB_t" offset="pxReadyTasks[i].pvOwner" cond="!(xSchedulerRunning==1 &amp;&amp; (pxReadyTasks[i].pvOwner == pxCurrentTCB))"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="Ready_TCB._count">
        <calc>
          sp = Ready_TCB[i].pxTopOfStack;

          Ready_TCB[i].StackAvailable = sp - Ready_TCB[i].pxStack;
          Ready_TCB[i].StackOverflow  = (sp &lt;= Ready_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Pending Ready Tasks -->
      <read name="xPendingReadyList" type="List_t" symbol="tasks.c/xPendingReadyList" cond="CV_En"/>
      
      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="CV_En">
        n = xPendingReadyList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="xPendingReadyList.uxNumberOfItems" cond="CV_En">
        <readlist name="pxPendingReadyTasks" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxPendingReadyTasks[pxPendingReadyTasks._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="xPendingReadyList.uxNumberOfItems" cond="CV_En">
        <readlist name="PendingReady_TCB" type="TCB_t" offset="pxPendingReadyTasks[i].pvOwner"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="PendingReady_TCB._count">
        <calc>
          sp = PendingReady_TCB[i].pxTopOfStack;

          PendingReady_TCB[i].StackAvailable = sp - PendingReady_TCB[i].pxStack;
          PendingReady_TCB[i].StackOverflow  = (sp &lt;= PendingReady_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Delayed Tasks -->
      <read name="DelayListAddr" type="uint32_t" symbol="tasks.c/pxDelayedTaskList" cond="CV_En"/>
      <read name="pxDelayedTaskList" type="List_t" offset="DelayListAddr"           cond="CV_En &amp;&amp; DelayListAddr"/>
      
      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="DelayListAddr">
        n = pxDelayedTaskList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="pxDelayedTaskList.uxNumberOfItems" cond="DelayListAddr">
        <readlist name="pxDelayedTasks" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxDelayedTasks[pxDelayedTasks._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="pxDelayedTaskList.uxNumberOfItems" cond="DelayListAddr">
        <readlist name="Delayed_TCB" type="TCB_t" offset="pxDelayedTasks[i].pvOwner"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="Delayed_TCB._count">
        <calc>
          sp = Delayed_TCB[i].pxTopOfStack;

          Delayed_TCB[i].StackAvailable = sp - Delayed_TCB[i].pxStack;
          Delayed_TCB[i].StackOverflow  = (sp &lt;= Delayed_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Overflow Delayed Tasks -->
      <read name="OverflowDelayListAddr" type="uint32_t" symbol="tasks.c/pxOverflowDelayedTaskList" cond="CV_En"/>
      <read name="pxOverflowDelayedTaskList" type="List_t" offset="OverflowDelayListAddr"           cond="CV_En &amp;&amp; OverflowDelayListAddr"/>

      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="OverflowDelayListAddr">
        n = pxOverflowDelayedTaskList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="pxOverflowDelayedTaskList.uxNumberOfItems" cond="OverflowDelayListAddr">
        <readlist name="pxOverflowDelayedTasks" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxOverflowDelayedTasks[pxOverflowDelayedTasks._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="pxOverflowDelayedTaskList.uxNumberOfItems" cond="OverflowDelayListAddr" >
        <readlist name="OverflowDelayed_TCB" type="TCB_t" offset="pxOverflowDelayedTasks[i].pvOwner"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="OverflowDelayed_TCB._count">
        <calc>
          sp = OverflowDelayed_TCB[i].pxTopOfStack;

          OverflowDelayed_TCB[i].StackAvailable = sp - OverflowDelayed_TCB[i].pxStack;
          OverflowDelayed_TCB[i].StackOverflow  = (sp &lt;= OverflowDelayed_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Suspended Tasks (Note: #if (INCLUDE_vTaskSuspend == 1)) -->
      <read name="xSuspendedTaskList" type="List_t" symbol="tasks.c/xSuspendedTaskList" cond="CV_En"/>

      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="CV_En">
        n = xSuspendedTaskList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="xSuspendedTaskList.uxNumberOfItems" cond="CV_En">
        <readlist name="pxSuspendedTasks" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxSuspendedTasks[pxSuspendedTasks._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="xSuspendedTaskList.uxNumberOfItems" cond="CV_En">
        <readlist name="Suspended_TCB" type="TCB_t" offset="pxSuspendedTasks[i].pvOwner"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="Suspended_TCB._count">
        <calc>
          sp = Suspended_TCB[i].pxTopOfStack;

          Suspended_TCB[i].StackAvailable = sp - Suspended_TCB[i].pxStack;
          Suspended_TCB[i].StackOverflow  = (sp &lt;= Suspended_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Tasks Waiting Termination (Note: #if(INCLUDE_vTaskDelete == 1)) -->
      <read name="xTasksWaitingTermination" type="List_t" symbol="tasks.c/xTasksWaitingTermination" cond="CV_En"/>

      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="CV_En">
        n = xTasksWaitingTermination.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="xTasksWaitingTermination.uxNumberOfItems" cond="CV_En">
        <readlist name="pxTasksWaitingTermination" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxTasksWaitingTermination[pxTasksWaitingTermination._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="xTasksWaitingTermination.uxNumberOfItems" cond="CV_En">
        <readlist name="WaitTermination_TCB" type="TCB_t" offset="pxTasksWaitingTermination[i].pvOwner"/>
      </list>

      <!-- Process control blocks -->
      <list name="i" start="0" limit="WaitTermination_TCB._count">
        <calc>
          sp = WaitTermination_TCB[i].pxTopOfStack;

          WaitTermination_TCB[i].StackAvailable = sp - WaitTermination_TCB[i].pxStack;
          WaitTermination_TCB[i].StackOverflow  = (sp &lt;= WaitTermination_TCB[i].pxStack);
        </calc>
      </list>


      <!-- Timers -->
      <read name="TimerListAddr"      type="uint32_t" symbol="timers.c/pxCurrentTimerList" cond="CV_En"/>
      <read name="pxCurrentTimerList" type="List_t"   offset="TimerListAddr"               cond="CV_En"/>
      
      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="TimerListAddr">
        n = pxCurrentTimerList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="pxCurrentTimerList.uxNumberOfItems" cond="TimerListAddr">
        <readlist name="pxCurrentTimers" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxCurrentTimers[pxCurrentTimers._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="pxCurrentTimers._count">
        <readlist cond="pxCurrentTimers[i].pvOwner" name="Timer_CB" type="Timer_t" offset="pxCurrentTimers[i].pvOwner"/>
      </list>

      <!-- Process Timer control blocks -->
      <list name="i" start="0" limit="Timer_CB._count">
        <!-- Read name string -->
        <list cond="Timer_CB[i].pcTimerName" name="j" start="0" limit="64">
          <read name="ch_0" type="uint8_t" offset="Timer_CB[i].pcTimerName + j"/>

          <calc>
            Timer_CB[i].Name[j] = ch_0;
          </calc>

          <calc cond="ch_0 == 0">
            j = 64;
          </calc>
        </list>
      </list>


      <!-- Overflow Timers -->
      <read name="OverflowTimerListAddr" type="uint32_t" symbol="timers.c/pxOverflowTimerList" cond="CV_En"/>
      <read name="pxOverflowTimerList"   type="List_t"   offset="OverflowTimerListAddr"        cond="CV_En"/>

      <!-- Determine address of first item in list, read current item and determine address of next item in list -->
      <calc cond="OverflowTimerListAddr">
        n = pxOverflowTimerList.xListEnd_pxNext;
      </calc>

      <list name="j" start="0" limit="pxOverflowTimerList.uxNumberOfItems" cond="OverflowTimerListAddr">
        <readlist name="pxOverflowTimers" type="ListItem_t" offset="n" count="1"/>

        <calc> n = pxOverflowTimers[pxOverflowTimers._count-1].pxNext; </calc>
      </list>

      <!-- Read control blocks -->
      <list name="i" start="0" limit="pxOverflowTimers._count">
        <readlist cond="pxOverflowTimers[i].pvOwner" name="OverflowTimer_CB" type="Timer_t" offset="pxOverflowTimers[i].pvOwner"/>
      </list>

      <!-- Process Timer control blocks -->
      <list name="i" start="0" limit="OverflowTimer_CB._count">
        <!-- Read name string -->
        <list cond="OverflowTimer_CB[i].pcTimerName" name="j" start="0" limit="64">
          <read name="ch_1" type="uint8_t" offset="OverflowTimer_CB[i].pcTimerName + j"/>

          <calc>
            OverflowTimer_CB[i].Name[j] = ch_1;
          </calc>

          <calc cond="ch_1 == 0">
            j = 64;
          </calc>
        </list>
      </list>


      <!-- Read Queue Registry (Queues, Semaphores, Mutexes) -->
      <calc cond="__Symbol_exists (&quot;queue.c/xQueueRegistry&quot;)">
        Queue_REG_Size = __size_of (&quot;queue.c/xQueueRegistry&quot;);
      </calc>
      
      <readlist cond="Queue_REG_Size != 0" name="Queue_REG" type="QueueRegistryItem_t" count="Queue_REG_Size" symbol="queue.c/xQueueRegistry"/>
      
      <!-- Read registered objects -->
      <list cond="Queue_REG_Size" name="i" start="0" limit="Queue_REG._count">
        <readlist cond="Queue_REG[i].xHandle != 0" name="Queue_CB" type="Queue_t" offset="Queue_REG[i].xHandle"/>

        <!-- Read name string -->
        <list name="n" start="0" limit="64" cond="(Queue_REG[i].xHandle != 0) &amp;&amp; (Queue_REG[i].pcQueueName != 0)">
          <read name="ch_2" type="uint8_t" offset="Queue_REG[i].pcQueueName + n"/>

          <calc>
            Queue_CB[Queue_CB._count-1].Name[n] = ch_2;
          </calc>

          <calc cond="ch_2 == 0">
            n = 64;
          </calc>
        </list>

      </list>

      <list cond="Queue_REG_Size" name="i" start="0" limit="Queue_CB._count">
        <!-- Queue -->
        <calc>
          Queue_CB[i].Type = 0;
        </calc>
        <!-- Mutex -->
        <calc cond="Queue_CB[i].pcHead == 0">
          Queue_CB[i].Type = 1;
          Queue_REG_Mutexes++;
        </calc>
        <!-- Semaphore -->
        <calc cond="Queue_CB[i].pcHead == Queue_CB[i]._addr">
          Queue_CB[i].Type = 2;
          Queue_REG_Semaphores++;
        </calc>

        <calc>
          Queue_REG_Queues = Queue_CB._count - Queue_REG_Mutexes - Queue_REG_Semaphores;
        </calc>
      </list>
      
      <!-- Check if enqueued objects exist on task list -->
      <list cond="Queue_REG_Size" name="i" start="0" limit="Queue_CB._count">
        <!-- Get address of Queue_t member xTasksWaitingToReceive -->
        <calc>
          n  = Queue_CB[i]._addr;
          n += 36;
        </calc>        
        
        <!-- Loop over delayed tasks -->
        <list name="j" start="0" limit="Delayed_TCB._count">
          <!-- Check if TCB waits for Event Group -->
          <calc cond="(Delayed_TCB[j].xEventListItem_xItemValue &amp; 0x80000000)">
            Delayed_TCB[j].WaitType  = 3;
            Delayed_TCB[j].WaitValue = Delayed_TCB[j].xEventListItem_xItemValue &amp; 0x00FFFFFF;
          </calc>
          <!-- Check if TCB exist on Queue_t list -->
          <calc cond="Delayed_TCB[j].xEventListItem_pvContainer == n">
            Delayed_TCB[j].WaitType  = Queue_CB[i].Type;
            Delayed_TCB[j].WaitValue = i;
          </calc>
        </list>

        <!-- Loop over overflow delayed tasks -->
        <list name="j" start="0" limit="OverflowDelayed_TCB._count">
          <!-- Check if TCB waits for Event Group -->
          <calc cond="(OverflowDelayed_TCB[j].xEventListItem_xItemValue &amp; 0x80000000)">
            OverflowDelayed_TCB[j].WaitType  = 3;
            OverflowDelayed_TCB[j].WaitValue = OverflowDelayed_TCB[j].xEventListItem_xItemValue &amp; 0x00FFFFFF;
          </calc>
          <!-- Check if TCB exist on Queue_t list -->
          <calc cond="OverflowDelayed_TCB[j].xEventListItem_pvContainer == n">
            OverflowDelayed_TCB[j].WaitType  = Queue_CB[i].Type;
            OverflowDelayed_TCB[j].WaitValue = i;
          </calc>
        </list>

      </list>

      <out name="FreeRTOS RTOS">
        <item property="Kernel" value="">
          <item property="Scheduler State"      value="%t[(CV_En &amp;&amp; xSchedulerRunning) ? &quot;Running&quot; : &quot;Not running&quot;]"/>
          <item property="Tick Pending"         value="%d[xPendedTicks]"           cond="CV_En &amp;&amp; xPendedTicks"/>
          <item property="Tick Count"           value="%d[xTickCount]"             cond="CV_En"/>
          <item property="Tick Count Overflows" value="%d[xNumOfOverflows]"        cond="CV_En &amp;&amp; xNumOfOverflows"/>
          <item property="Task Count"           value="%d[uxCurrentNumberOfTasks]" cond="CV_En"/>
        </item>

        <item property="Running Task" value="" cond="CV_En &amp;&amp; xSchedulerRunning">
          <item property="h: %x[pxCurrentTCB] %t[Running_TCB.pcTaskName]" value="">
            <item property="Priority"    value="%d[Running_TCB.uxPriority]" />
            <item property="Stack Limit" value="%x[Running_TCB.pxStack]" />
            <item property="Stack Top"   value="%x[Running_TCB.pxTopOfStack]" />
            <item>
              <print cond="Running_TCB.StackOverflow == 0" property="Stack Available" value="%d[Running_TCB.StackAvailable] bytes"/>
              <print cond="Running_TCB.StackOverflow != 0" property="Stack Overflow"  value="%d[Running_TCB.StackAvailable] bytes" bold="1" alert="1"/>
            </item>
          </item>
        </item>

        <item property="Ready Tasks (%d[Ready_TCB._count])" value="">
          <list name="i" start="0" limit="Ready_TCB._count">
            <item property="h: %x[Ready_TCB[i]._addr] %t[Ready_TCB[i].pcTaskName]" value="">
              <item property="Priority"    value="%d[Ready_TCB[i].uxPriority]" />
              <item property="Stack Limit" value="%x[Ready_TCB[i].pxStack]" />
              <item property="Stack Top"   value="%x[Ready_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="Ready_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[Ready_TCB[i].StackAvailable] bytes"/>
                <print cond="Ready_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[Ready_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Pending Ready Tasks (%d[PendingReady_TCB._count])" value="" cond="PendingReady_TCB._count">
          <list name="i" start="0" limit="PendingReady_TCB._count">
            <item property="h: %x[PendingReady_TCB[i]._addr] %t[PendingReady_TCB[i].pcTaskName]" value="">
              <item property="Priority"    value="%d[PendingReady_TCB[i].uxPriority]" />
              <item property="Stack Limit" value="%x[PendingReady_TCB[i].pxStack]" />
              <item property="Stack Top"   value="%x[PendingReady_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="PendingReady_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[PendingReady_TCB[i].StackAvailable] bytes"/>
                <print cond="PendingReady_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[PendingReady_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Delayed Tasks (%d[Delayed_TCB._count])" value="">
          <list name="i" start="0" limit="Delayed_TCB._count">
            <item property="h: %x[Delayed_TCB[i]._addr] %t[Delayed_TCB[i].pcTaskName]" value="">

              <item cond="Queue_REG_Size">
                <print cond="Delayed_TCB[i].WaitType == 0" property="Waiting Queue"      value="h: %x[Queue_CB[Delayed_TCB[i].WaitValue]._addr] %t[Queue_CB[Delayed_TCB[i].WaitValue].Name]"/>
                <print cond="Delayed_TCB[i].WaitType == 1" property="Waiting Mutex"      value="h: %x[Queue_CB[Delayed_TCB[i].WaitValue]._addr] %t[Queue_CB[Delayed_TCB[i].WaitValue].Name]"/>
                <print cond="Delayed_TCB[i].WaitType == 2" property="Waiting Semaphore"  value="h: %x[Queue_CB[Delayed_TCB[i].WaitValue]._addr] %t[Queue_CB[Delayed_TCB[i].WaitValue].Name]"/>
                <print cond="Delayed_TCB[i].WaitType == 3" property="Waiting EventGroup" value="Flags: %x[Delayed_TCB[i].WaitValue]"/>
              </item>

              <item property="Wake time"   value="%d[Delayed_TCB[i].xStateListItem_xItemValue]" />
              <item property="Priority"    value="%d[Delayed_TCB[i].uxPriority]" />
              <item property="Stack Limit" value="%x[Delayed_TCB[i].pxStack]" />
              <item property="Stack Top"   value="%x[Delayed_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="Delayed_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[Delayed_TCB[i].StackAvailable] bytes"/>
                <print cond="Delayed_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[Delayed_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Overflow Delayed Tasks (%d[OverflowDelayed_TCB._count])" value="" cond="OverflowDelayed_TCB._count">
          <list name="i" start="0" limit="OverflowDelayed_TCB._count">
            <item property="h: %x[OverflowDelayed_TCB[i]._addr] %t[OverflowDelayed_TCB[i].pcTaskName]" value="">

              <item cond="Queue_REG_Size">
                <print cond="OverflowDelayed_TCB[i].WaitType == 0" property="Waiting Queue"      value="h: %x[Queue_CB[OverflowDelayed_TCB[i].WaitValue]._addr] %t[Queue_CB[OverflowDelayed_TCB[i].WaitValue].Name]"/>
                <print cond="OverflowDelayed_TCB[i].WaitType == 1" property="Waiting Mutex"      value="h: %x[Queue_CB[OverflowDelayed_TCB[i].WaitValue]._addr] %t[Queue_CB[OverflowDelayed_TCB[i].WaitValue].Name]"/>
                <print cond="OverflowDelayed_TCB[i].WaitType == 2" property="Waiting Semaphore"  value="h: %x[Queue_CB[OverflowDelayed_TCB[i].WaitValue]._addr] %t[Queue_CB[OverflowDelayed_TCB[i].WaitValue].Name]"/>
                <print cond="OverflowDelayed_TCB[i].WaitType == 3" property="Waiting EventGroup" value="Flags=%x[OverflowDelayed_TCB[i].WaitValue]"/>
              </item>

              <item property="Wake time"   value="%d[OverflowDelayed_TCB[i].xStateListItem_xItemValue]" />
              <item property="Priority"    value="%d[OverflowDelayed_TCB[i].uxPriority]" />
              <item property="Stack Limit" value="%x[OverflowDelayed_TCB[i].pxStack]" />
              <item property="Stack Top"   value="%x[OverflowDelayed_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="OverflowDelayed_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[OverflowDelayed_TCB[i].StackAvailable] bytes"/>
                <print cond="OverflowDelayed_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[OverflowDelayed_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Suspended Tasks (%d[Suspended_TCB._count])" value="">
          <list name="i" start="0" limit="Suspended_TCB._count">
            <item property="h: %x[Suspended_TCB[i]._addr] %t[Suspended_TCB[i].pcTaskName]" value="">
              <item property="Priority"    value="%d[Suspended_TCB[i].uxPriority]" />
              <item property="Stack Limit" value="%x[Suspended_TCB[i].pxStack]" />
              <item property="Stack Top"   value="%x[Suspended_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="Suspended_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[Suspended_TCB[i].StackAvailable] bytes"/>
                <print cond="Suspended_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[Suspended_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Waiting Termination Tasks (%d[WaitTermination_TCB._count])" value="" cond="WaitTermination_TCB._count">
          <list name="i" start="0" limit="WaitTermination_TCB._count">
            <item property="h: %x[WaitTermination_TCB[i]._addr] %t[WaitTermination_TCB[i].pcTaskName]" value="">
              <item property="Priority"        value="%d[WaitTermination_TCB[i].uxPriority]" />
              <item property="Stack Limit"     value="%x[WaitTermination_TCB[i].pxStack]" />
              <item property="Stack Top"       value="%x[WaitTermination_TCB[i].pxTopOfStack]" />
              <item>
                <print cond="WaitTermination_TCB[i].StackOverflow == 0" property="Stack Available" value="%d[WaitTermination_TCB[i].StackAvailable] bytes"/>
                <print cond="WaitTermination_TCB[i].StackOverflow != 0" property="Stack Overflow"  value="%d[WaitTermination_TCB[i].StackAvailable] bytes" bold="1" alert="1"/>
              </item>
            </item>
          </list>
        </item>

        <item property="Timers (%d[Timer_CB._count])" value="">
          <list name="i" start="0" limit="Timer_CB._count">
            <item property="h: %x[Timer_CB[i]._addr] %t[Timer_CB[i].Name]" value="">
              <item property="Wake Time"   value="%d[Timer_CB[i].xTimerListItem_xItemValue]" />
              <item property="Period"      value="%d[Timer_CB[i].xTimerPeriodInTicks]" />
              <item property="ID"          value="%x[Timer_CB[i].pvTimerID]" />
              <item property="Callback"    value="%S[Timer_CB[i].pxCallbackFunction]" />
            </item>
          </list>
        </item>

        <item property="Overflowed Timers (%d[OverflowTimer_CB._count])" value="" cond="OverflowTimer_CB._count">
          <list name="i" start="0" limit="OverflowTimer_CB._count">
            <item property="h: %x[OverflowTimer_CB[i]._addr] %t[OverflowTimer_CB[i].Name]" value="">
              <item property="Wake Time"   value="%d[OverflowTimer_CB[i].xTimerListItem_xItemValue]" />
              <item property="Period"      value="%d[OverflowTimer_CB[i].xTimerPeriodInTicks]" />
              <item property="ID"          value="%x[OverflowTimer_CB[i].pvTimerID]" />
              <item property="Callback"    value="%S[OverflowTimer_CB[i].pxCallbackFunction]" />
            </item>
          </list>
        </item>

        <item property="Mutexes (%d[Queue_REG_Mutexes])" value="" cond="Queue_REG_Size">
          <list name="i" start="0" limit="Queue_CB._count">          
            <item property="h: %x[Queue_CB[i]._addr] %t[Queue_CB[i].Name]" value="" cond="Queue_CB[i].Type == 1">
              <item property="State" value="%t[Queue_CB[i].uxMessagesWaiting == 0 ? &quot;Locked&quot; : &quot;Released&quot;]" />
              <item property="Recursive counter" value="%d[Queue_CB[i].u_uxRecursiveCallCount]" cond="Queue_CB[i].u_uxRecursiveCallCount"/>
              <item property="Owner thread" value="h: %x[Queue_CB[i].pcTail]" cond="Queue_CB[i].pcTail != 0"/>
            </item>
          </list>
        </item>

        <item property="Semaphores (%d[Queue_REG_Semaphores])" value="" cond="Queue_REG_Size">
          <list name="i" start="0" limit="Queue_CB._count">
            <item property="h: %x[Queue_CB[i]._addr] %t[Queue_CB[i].Name]" value="" cond="Queue_CB[i].Type == 2">
              <item property="Tokens"     value="%d[Queue_CB[i].uxMessagesWaiting]" />
              <item property="Max Tokens" value="%d[Queue_CB[i].uxLength]" />
            </item>
          </list>
        </item>

        <item property="Queues (%d[Queue_REG_Queues])" value="" cond="Queue_REG_Size">
          <list name="i" start="0" limit="Queue_CB._count">
            <item property="h: %x[Queue_CB[i]._addr] %t[Queue_CB[i].Name]" value="" cond="Queue_CB[i].Type == 0">
              <item property="Objects"     value="%d[Queue_CB[i].uxMessagesWaiting]" />
              <item property="Max Objects" value="%d[Queue_CB[i].uxLength]"/>
              <item property="Object size" value="%d[Queue_CB[i].uxItemSize]"/>

              <!-- Queued messages -->
              <item cond="Queue_CB[i].uxMessagesWaiting" property="Queue (%d[Queue_CB[i].uxMessagesWaiting])" value="">
                <list name="j" start="0" limit="Queue_CB[i].uxMessagesWaiting">
                  <item property="Queue[%d[j]]" value="Address: %x[Queue_CB[i].pcHead + (j * Queue_CB[i].uxItemSize)]" />
                </list>
              </item>

            </item>
          </list>
        </item>

      </out>
    </object>
  </objects>

  <events>

    <group name="FreeRTOS RTOS">
      <component name="Tasks Events"       brief="FreeRTOS Tasks"       no="0xF0" prefix="EvrFreeRTOSTasks_"       info="FreeRTOS Tasks Events">
        <state name="Inactive"    plot="off"                       />
        <state name="Ready"       plot="box"                       />
        <state name="Running"     plot="box"  bold="1" unique="1"  />
        <state name="Blocked"     plot="line"                      />
        <state name="Not-running" plot="line" bold="1" dormant="1" />
      </component>
      <component name="Queue Events"         brief="FreeRTOS Queue"        no="0xF1" prefix="EvrFreeRTOSQueue_"       info="FreeRTOS Queue Events"/>
      <component name="Timers Events"        brief="FreeRTOS Timers"       no="0xF2" prefix="EvrFreeRTOSTimers_"      info="FreeRTOS Timers Events"/>
      <component name="EventGroups Events"   brief="FreeRTOS EventGroups"  no="0xF3" prefix="EvrFreeRTOSEventGroups_" info="FreeRTOS Event Groups Events"/>
      <component name="Heap Events"          brief="FreeRTOS Heap"         no="0xF4" prefix="EvrFreeRTOSHeap_"        info="FreeRTOS Heap Events"/>
      <component name="Stream Buffer Events" brief="FreeRTOS StreamBuffer" no="0xF5" prefix="EvrFreeRTOSStreamBuf_"   info="FreeRTOS Stream Buffer Events"/>
    </group>

    <event id="0xF000 + 0xFF" level="Op"     property="TaskTrackingReset"                                        tracking="Reset" value="" info=""/>
    <event id="0xF000 + 0x00" level="Op"     property="TaskCreate"                state="Inactive" handle="val1" tracking="Start" value="pxNewTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x01" level="Error"  property="TaskCreateFailed"                                                          value="" info=""/>
    <event id="0xF000 + 0x02" level="Op"     property="TaskDelete"                state="Inactive" handle="val1" tracking="Stop"  value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x03" level="Op"     property="TaskDelayUntil"                                                            value="xTimeToWake=%d[val1]" info=""/>
    <event id="0xF000 + 0x04" level="Op"     property="TaskDelay"                                                                 value="xTicksToDelay=%d[val1]" info=""/>
    <event id="0xF000 + 0x05" level="Op"     property="TaskPrioritySet"                                                           value="pxTCB=%x[val1], uxNewPriority=%d[val2]" info=""/>
    <event id="0xF000 + 0x06" level="Op"     property="TaskSuspend"               state="Blocked"  handle="val1"                  value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x07" level="Op"     property="TaskResume"                                                                value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x08" level="Op"     property="TaskResumeFromIsr"                                                         value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x09" level="Detail" property="TaskIncrementTick"                                                         value="xTickCount=%d[val1]" info=""/>
    <event id="0xF000 + 0x0A" level="Op"     property="IncreaseTickCount"                                                         value="xTicksToJump=%d[val1]" info=""/>
    <event id="0xF000 + 0x0B" level="Op"     property="TaskSwitchedOut"           state="Blocked"  handle="val1"                  value="pxCurrentTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x0C" level="Op"     property="TaskSwitchedIn"            state="Running"  handle="val1"                  value="pxCurrentTCB=%x[val1], priority=%d[val2]" info=""/>
    <event id="0xF000 + 0x0D" level="Op"     property="TaskPriorityInherit"                                                       value="pxTCBOfMutexHolder=%x[val1], uxInheritedPriority=%d[val2]" info=""/>
    <event id="0xF000 + 0x0E" level="Op"     property="TaskPriorityDisinherit"                                                    value="pxTCBOfMutexHolder=%x[val1], uxOriginalPriority=%d[val2]" info=""/>
    <event id="0xF000 + 0x0F" level="Op"     property="MovedTaskToReadyState"     state="Ready"    handle="val1"                  value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x10" level="Op"     property="PostMovedTaskToReadyState"                                                 value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x11" level="Op"     property="LowPowerIdleBegin"                                                         value="xExpectedIdleTime=%d[val1]" info=""/>
    <event id="0xF000 + 0x12" level="Op"     property="LowPowerIdleEnd"                                                           value="" info=""/>
    <event id="0xF000 + 0x13" level="Op"     property="TaskNotifyTakeBlock"                                                       value="uxIndexToWait=%d[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF000 + 0x14" level="Op"     property="TaskNotifyTake"                                                            value="uxIndexToWait=%d[val1], ulNotifiedValue=%x[val2]" info=""/>
    <event id="0xF000 + 0x15" level="Op"     property="TaskNotifyWaitBlock"                                                       value="uxIndexToWait=%d[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF000 + 0x16" level="Op"     property="TaskNotifyWait"                                                            value="uxIndexToWait=%d[val1], ulNotifiedValue=%x[val2]" info=""/>
    <event id="0xF000 + 0x17" level="Op"     property="TaskNotify"                                                                value="xTaskToNotify=%x[val1], uxIndexToWait=%x[val2], eAction=%x[val3], ulNotifiedValue=%x[val4]" info=""/>
    <event id="0xF000 + 0x18" level="Op"     property="TaskNotifyFromIsr"                                                         value="xTaskToNotify=%x[val1], uxIndexToWait=%x[val2], eAction=%x[val3], ulNotifiedValue=%x[val4]" info=""/>
    <event id="0xF000 + 0x19" level="Op"     property="TaskNotifyGiveFromIsr"                                                     value="xTaskToNotify=%x[val1], uxIndexToWait=%x[val2], ulNotifiedValue=%x[val3]" info=""/>    
    <event id="0xF000 + 0x1A" level="Op"     property="MovedTaskToDelayedList"                                                    value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x1B" level="Op"     property="MovedTaskToOverflowDelayedList"                                            value="pxTCB=%x[val1]" info=""/>

    <event id="0xF000 + 0x20" level="API"    property="xTaskCreateStatic"                              value="pxTaskCode=%x[val1], pcName=%x[val2], ulStackDepth=%d[val3], pvParameters=%x[val4]" info=""/>
    <event id="0xF000 + 0x21" level="API"    property="xTaskCreateStatic"                              value="uxPriority=%d[val1], puxStackBuffer=%x[val2], pxTaskBuffer=%x[val3]" info=""/>
    <event id="0xF000 + 0x22" level="Op"     property="xTaskCreateStatic_Return"                       value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x23" level="API"    property="xTaskCreateStaticAffinitySet"                   value="pxTaskCode=%x[val1], pcName=%x[val2], ulStackDepth=%d[val3], pvParameters=%x[val4]" info=""/>
    <event id="0xF000 + 0x24" level="API"    property="xTaskCreateStaticAffinitySet"                   value="uxPriority=%d[val1], puxStackBuffer=%x[val2], pxTaskBuffer=%x[val3], uxCoreAffinityMask=%x[val4]" info=""/>
    <event id="0xF000 + 0x25" level="Op"     property="xTaskCreateStaticAffinitySet_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x26" level="API"    property="xTaskCreateRestrictedStatic"                    value="pxTaskDefinition=%x[val1], pxCreatedTask=%x[val2]" info=""/>
    <event id="0xF000 + 0x27" level="Op"     property="xTaskCreateRestrictedStatic_Return"             value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x28" level="API"    property="xTaskCreateRestrictedStaticAffinitySet"         value="pxTaskDefinition=%x[val1], uxCoreAffinityMask=%x[val2], pxCreatedTask=%x[val3]" info=""/>
    <event id="0xF000 + 0x29" level="Op"     property="xTaskCreateRestrictedStaticAffinitySet_Return"  value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x2A" level="API"    property="xTaskCreateRestricted"                          value="pxTaskDefinition=%x[val1], pxCreatedTask=%x[val2]" info=""/>
    <event id="0xF000 + 0x2B" level="Op"     property="xTaskCreateRestricted_Return"                   value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x2C" level="API"    property="xTaskCreateRestrictedAffinitySet"               value="pxTaskDefinition=%x[val1], uxCoreAffinityMask=%x[val2], pxCreatedTask=%x[val3]" info=""/>
    <event id="0xF000 + 0x2D" level="Op"     property="xTaskCreateRestrictedAffinitySet_Return"        value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x2E" level="API"    property="xTaskCreate"                                    value="pxTaskCode=%x[val1], pcName=%x[val2], uxStackDepth=%d[val3], pvParameters=%x[val4]" info=""/>
    <event id="0xF000 + 0x2F" level="API"    property="xTaskCreate"                                    value="uxPriority=%d[val1], pxCreatedTask=%x[val2]" info=""/>
    <event id="0xF000 + 0x30" level="Op"     property="xTaskCreate_Return"                             value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x31" level="API"    property="xTaskCreateAffinitySet"                         value="pxTaskCode=%x[val1], pcName=%x[val2], uxStackDepth=%d[val3], pvParameters=%x[val4]" info=""/>
    <event id="0xF000 + 0x32" level="API"    property="xTaskCreateAffinitySet"                         value="uxPriority=%d[val1], uxCoreAffinityMask=%x[val2], pxCreatedTask=%x[val3]" info=""/>
    <event id="0xF000 + 0x33" level="Op"     property="xTaskCreateAffinitySet_Return"                  value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x34" level="API"    property="vTaskDelete"                                    value="xTaskToDelete=%x[val1]" info=""/>
    <event id="0xF000 + 0x35" level="Op"     property="vTaskDelete_Return"                             value="" info=""/>
    <event id="0xF000 + 0x36" level="API"    property="xTaskDelayUntil"                                value="pxPreviousWakeTime=%d[val1], xTimeIncrement=%d[val2]" info=""/>
    <event id="0xF000 + 0x37" level="Op"     property="xTaskDelayUntil_Return"                         value="xShouldDelay=%d[val1]" info=""/>
    <event id="0xF000 + 0x38" level="API"    property="vTaskDelay"                                     value="xTicksToDelay=%d[val1]" info=""/>
    <event id="0xF000 + 0x39" level="Op"     property="vTaskDelay_Return"                              value="" info=""/>
    <event id="0xF000 + 0x3A" level="API"    property="eTaskGetState"                                  value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x3B" level="Op"     property="eTaskGetState_Return"                           value="eReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x3C" level="API"    property="uxTaskPriorityGet"                              value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x3D" level="Op"     property="uxTaskPriorityGet_Return"                       value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x3E" level="API"    property="uxTaskPriorityGetFromISR"                       value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x3F" level="Op"     property="uxTaskPriorityGetFromISR_Return"                value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x40" level="API"    property="uxTaskBasePriorityGet"                          value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x41" level="Op"     property="uxTaskBasePriorityGet_Return"                   value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x42" level="API"    property="uxTaskBasePriorityGetFromISR"                   value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x43" level="Op"     property="uxTaskBasePriorityGetFromISR_Return"            value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x44" level="API"    property="vTaskPrioritySet"                               value="xTask=%x[val1], uxNewPriority=%d[val2]" info=""/>
    <event id="0xF000 + 0x45" level="Op"     property="vTaskPrioritySet_Return"                        value="" info=""/>
    <event id="0xF000 + 0x46" level="API"    property="vTaskCoreAffinitySet"                           value="xTask=%x[val1], uxCoreAffinityMask=%d[val2]" info=""/>
    <event id="0xF000 + 0x47" level="Op"     property="vTaskCoreAffinitySet_Return"                    value="" info=""/>
    <event id="0xF000 + 0x48" level="API"    property="vTaskCoreAffinityGet"                           value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x49" level="Op"     property="vTaskCoreAffinityGet_Return"                    value="uxCoreAffinityMask=%d[val1]" info=""/>
    <event id="0xF000 + 0x4A" level="API"    property="vTaskPreemptionDisable"                         value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x4B" level="Op"     property="vTaskPreemptionDisable_Return"                  value="" info=""/>
    <event id="0xF000 + 0x4C" level="API"    property="vTaskPreemptionEnable"                          value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x4D" level="Op"     property="vTaskPreemptionEnable_Return"                   value="" info=""/>
    <event id="0xF000 + 0x4E" level="API"    property="vTaskSuspend"                                   value="xTaskToSuspend=%x[val1]" info=""/>
    <event id="0xF000 + 0x4F" level="Op"     property="vTaskSuspend_Return"                            value="" info=""/>
    <event id="0xF000 + 0x50" level="API"    property="vTaskResume"                                    value="xTaskToResume=%x[val1]" info=""/>
    <event id="0xF000 + 0x51" level="Op"     property="vTaskResume_Return"                             value="" info=""/>
    <event id="0xF000 + 0x52" level="API"    property="xTaskResumeFromISR"                             value="xTaskToResume=%x[val1]" info=""/>
    <event id="0xF000 + 0x53" level="Op"     property="xTaskResumeFromISR_Return"                      value="xYieldRequired=%d[val1]" info=""/>
    <event id="0xF000 + 0x54" level="API"    property="vTaskStartScheduler"                            value="" info=""/>
    <event id="0xF000 + 0x55" level="Op"     property="vTaskStartScheduler_Return"                     value="" info=""/>
    <event id="0xF000 + 0x56" level="API"    property="vTaskEndScheduler"                              value="" info=""/>
    <event id="0xF000 + 0x57" level="Op"     property="vTaskEndScheduler_Return"                       value="" info=""/>
    <event id="0xF000 + 0x58" level="API"    property="vTaskSuspendAll"                                value="" info=""/>
    <event id="0xF000 + 0x59" level="Op"     property="vTaskSuspendAll_Return"                         value="" info=""/>
    <event id="0xF000 + 0x5A" level="API"    property="xTaskResumeAll"                                 value="" info=""/>
    <event id="0xF000 + 0x5B" level="Op"     property="xTaskResumeAll_Return"                          value="xAlreadyYielded=%d[val1]" info=""/>
    <event id="0xF000 + 0x5C" level="API"    property="xTaskGetTickCount"                              value="" info=""/>
    <event id="0xF000 + 0x5D" level="Op"     property="xTaskGetTickCount_Return"                       value="xTicks=%d[val1]" info=""/>
    <event id="0xF000 + 0x5E" level="API"    property="xTaskGetTickCountFromISR"                       value="" info=""/>
    <event id="0xF000 + 0x5F" level="Op"     property="xTaskGetTickCountFromISR_Return"                value="xTicks=%d[val1]" info=""/>
    <event id="0xF000 + 0x60" level="API"    property="uxTaskGetNumberOfTasks"                         value="" info=""/>
    <event id="0xF000 + 0x61" level="Op"     property="uxTaskGetNumberOfTasks_Return"                  value="uxCurrentNumberOfTasks=%d[val1]" info=""/>
    <event id="0xF000 + 0x62" level="API"    property="pcTaskGetName"                                  value="xTaskToQuery=%x[val1]" info=""/>
    <event id="0xF000 + 0x63" level="Op"     property="pcTaskGetName_Return"                           value="pcTaskName=%s[val1]" info=""/>
    <event id="0xF000 + 0x64" level="API"    property="xTaskGetHandle"                                 value="pcNameToQuery=%s[val1]" info=""/>
    <event id="0xF000 + 0x65" level="Op"     property="xTaskGetHandle_Return"                          value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0x66" level="API"    property="xTaskGetStaticBuffers"                          value="xTask=%x[val1], ppuxStackBuffer=%x[val2], ppxTaskBuffer=%x[val3]" info=""/>
    <event id="0xF000 + 0x67" level="Op"     property="xTaskGetStaticBuffers_Return"                   value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x68" level="API"    property="uxTaskGetSystemState"                           value="pxTaskStatusArray=%x[val1], uxArraySize=%d[val2], pulTotalRunTime=%d[val3]" info=""/>
    <event id="0xF000 + 0x69" level="Op"     property="uxTaskGetSystemState_Return"                    value="uxTask=%d[val1]" info=""/>
    <event id="0xF000 + 0x6A" level="API"    property="xTaskGetIdleTaskHandle"                         value="" info=""/>
    <event id="0xF000 + 0x6B" level="Op"     property="xTaskGetIdleTaskHandle_Return"                  value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x6C" level="API"    property="xTaskGetIdleTaskHandleForCore"                  value="xCoreID=%d[val1]" info=""/>
    <event id="0xF000 + 0x6D" level="Op"     property="xTaskGetIdleTaskHandleForCore_Return"           value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x6E" level="API"    property="vTaskStepTick"                                  value="xTicksToJump=%d[val1]" info=""/>
    <event id="0xF000 + 0x6F" level="Op"     property="vTaskStepTick_Return"                           value="" info=""/>
    <event id="0xF000 + 0x70" level="API"    property="xTaskCatchUpTicks"                              value="xTicksToCatchUp=%d[val1]" info=""/>
    <event id="0xF000 + 0x71" level="Op"     property="xTaskCatchUpTicks_Return"                       value="xYieldOccurred=%d[val1]" info=""/>
    <event id="0xF000 + 0x72" level="API"    property="xTaskAbortDelay"                                value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x73" level="Op"     property="xTaskAbortDelay_Return"                         value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x74" level="API"    property="xTaskIncrementTick"                             value="" info=""/>
    <event id="0xF000 + 0x75" level="Op"     property="xTaskIncrementTick_Return"                      value="xSwitchRequired=%d[val1]" info=""/>
    <event id="0xF000 + 0x76" level="API"    property="vTaskSetApplicationTaskTag"                     value="xTask=%x[val1], pxHookFunction=%x[val2]" info=""/>
    <event id="0xF000 + 0x77" level="Op"     property="vTaskSetApplicationTaskTag_Return"              value="" info=""/>
    <event id="0xF000 + 0x78" level="API"    property="xTaskGetApplicationTaskTag"                     value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x79" level="Op"     property="xTaskGetApplicationTaskTag_Return"              value="xReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0x7A" level="API"    property="xTaskGetApplicationTaskTagFromISR"              value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x7B" level="Op"     property="xTaskGetApplicationTaskTagFromISR_Return"       value="xReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0x7C" level="API"    property="xTaskCallApplicationTaskHook"                   value="xTask=%x[val1], pvParameter=%x[val2]" info=""/>
    <event id="0xF000 + 0x7D" level="Op"     property="xTaskCallApplicationTaskHook_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x7E" level="API"    property="vTaskSwitchContext"                             value="" info=""/>
    <event id="0xF000 + 0x7F" level="Op"     property="vTaskSwitchContext_Return"                      value="" info=""/>
    <event id="0xF000 + 0x80" level="API"    property="vTaskPlaceOnEventList"                          value="pxEventList=%x[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF000 + 0x81" level="Op"     property="vTaskPlaceOnEventList_Return"                   value="" info=""/>
    <event id="0xF000 + 0x82" level="API"    property="vTaskPlaceOnUnorderedEventList"                 value="pxEventList=%x[val1], xItemValue=%d[val2], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF000 + 0x83" level="Op"     property="vTaskPlaceOnUnorderedEventList_Return"          value="" info=""/>
    <event id="0xF000 + 0x84" level="API"    property="vTaskPlaceOnEventListRestricted"                value="pxEventList=%x[val1], xTicksToWait=%d[val2], xWaitIndefinitely=%d[val3]" info=""/>
    <event id="0xF000 + 0x85" level="Op"     property="vTaskPlaceOnEventListRestricted_Return"         value="" info=""/>
    <event id="0xF000 + 0x86" level="API"    property="xTaskRemoveFromEventList"                       value="pxEventList=%x[val1]" info=""/>
    <event id="0xF000 + 0x87" level="Op"     property="xTaskRemoveFromEventList_Return"                value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x88" level="API"    property="vTaskRemoveFromUnorderedEventList"              value="pxEventListItem=%x[val1], xItemValue=%d[val2]" info=""/>
    <event id="0xF000 + 0x89" level="Op"     property="vTaskRemoveFromUnorderedEventList_Return"       value="" info=""/>
    <event id="0xF000 + 0x8A" level="API"    property="vTaskSetTimeOutState"                           value="pxTimeOut=%x[val1]" info=""/>
    <event id="0xF000 + 0x8B" level="Op"     property="vTaskSetTimeOutState_Return"                    value="" info=""/>
    <event id="0xF000 + 0x8C" level="API"    property="vTaskInternalSetTimeOutState"                   value="pxTimeOut=%x[val1]" info=""/>
    <event id="0xF000 + 0x8D" level="Op"     property="vTaskInternalSetTimeOutState_Return"            value="" info=""/>
    <event id="0xF000 + 0x8E" level="API"    property="xTaskCheckForTimeOut"                           value="pxTimeOut=%x[val1], pxTicksToWait=%x[val2]" info=""/>
    <event id="0xF000 + 0x8F" level="Op"     property="xTaskCheckForTimeOut_Return"                    value="" info=""/>
    <event id="0xF000 + 0x90" level="API"    property="vTaskMissedYield"                               value="" info=""/>
    <event id="0xF000 + 0x91" level="Op"     property="vTaskMissedYield_Return"                        value="" info=""/>
    <event id="0xF000 + 0x92" level="API"    property="uxTaskGetTaskNumber"                            value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0x93" level="Op"     property="uxTaskGetTaskNumber_Return"                     value="uxReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0x94" level="API"    property="vTaskSetTaskNumber"                             value="xTask=%x[val1], uxHandle=%d[val2]" info=""/>
    <event id="0xF000 + 0x95" level="Op"     property="vTaskSetTaskNumber_Return"                      value="" info=""/>
    <event id="0xF000 + 0x96" level="API"    property="eTaskConfirmSleepModeStatus"                    value="" info=""/>
    <event id="0xF000 + 0x97" level="Op"     property="eTaskConfirmSleepModeStatus_Return"             value="eReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0x98" level="API"    property="vTaskSetThreadLocalStoragePointer"              value="xTaskToSet=%x[val1], xIndex=%d[val2], pvValue=%x[val3]" info=""/>
    <event id="0xF000 + 0x99" level="Op"     property="vTaskSetThreadLocalStoragePointer_Return"       value="" info=""/>
    <event id="0xF000 + 0x9A" level="API"    property="pvTaskGetThreadLocalStoragePointer"             value="xTaskToQuery=%x[val1], xIndex=%d[val2]" info=""/>
    <event id="0xF000 + 0x9B" level="Op"     property="pvTaskGetThreadLocalStoragePointer_Return"      value="pvReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0x9C" level="API"    property="vTaskAllocateMPURegions"                        value="xTaskToModify=%x[val1], pxRegions=%x[val2]" info=""/>
    <event id="0xF000 + 0x9D" level="Op"     property="vTaskAllocateMPURegions_Return"                 value="" info=""/>
    <event id="0xF000 + 0x9E" level="API"    property="vTaskGetInfo"                                   value="xTask=%x[val1], pxTaskStatus=%x[val2], xGetFreeStackSpace=%d[val3], eState=%x[val4]" info=""/>
    <event id="0xF000 + 0x9F" level="Op"     property="vTaskGetInfo_Return"                            value="" info=""/>
    <event id="0xF000 + 0xA0" level="API"    property="uxTaskGetStackHighWaterMark2"                   value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0xA1" level="Op"     property="uxTaskGetStackHighWaterMark2_Return"            value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xA2" level="API"    property="uxTaskGetStackHighWaterMark"                    value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0xA3" level="Op"     property="uxTaskGetStackHighWaterMark_Return"             value="uxReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xA4" level="API"    property="xTaskGetCurrentTaskHandle"                      value="" info=""/>
    <event id="0xF000 + 0xA5" level="Op"     property="xTaskGetCurrentTaskHandle_Return"               value="xReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0xA6" level="API"    property="xTaskGetCurrentTaskHandleForCore"               value="xCoreID=%x[val1]" info=""/>
    <event id="0xF000 + 0xA7" level="Op"     property="xTaskGetCurrentTaskHandleForCore_Return"        value="xReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0xA8" level="API"    property="xTaskGetSchedulerState"                         value="" info=""/>
    <event id="0xF000 + 0xA9" level="Op"     property="xTaskGetSchedulerState_Return"                  value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xAA" level="API"    property="xTaskPriorityInherit"                           value="pxMutexHolder=%x[val1]" info=""/>
    <event id="0xF000 + 0xAB" level="Op"     property="xTaskPriorityInherit_Return"                    value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xAC" level="API"    property="xTaskPriorityDisinherit"                        value="pxMutexHolder=%x[val1]" info=""/>
    <event id="0xF000 + 0xAD" level="Op"     property="xTaskPriorityDisinherit_Return"                 value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xAE" level="API"    property="vTaskPriorityDisinheritAfterTimeout"            value="pxMutexHolder=%x[val1], uxHighestPriorityWaitingTask=%d[val2]" info=""/>
    <event id="0xF000 + 0xAF" level="Op"     property="vTaskPriorityDisinheritAfterTimeout_Return"     value="" info=""/>
    <event id="0xF000 + 0xB0" level="API"    property="vTaskYieldWithinAPI"                            value="" info=""/>
    <event id="0xF000 + 0xB1" level="Op"     property="vTaskYieldWithinAPI_Return"                     value="" info=""/>
    <event id="0xF000 + 0xB2" level="API"    property="vTaskEnterCritical"                             value="" info=""/>
    <event id="0xF000 + 0xB3" level="Op"     property="vTaskEnterCritical_Return"                      value="" info=""/>
    <event id="0xF000 + 0xB4" level="API"    property="vTaskEnterCriticalFromISR"                      value="" info=""/>
    <event id="0xF000 + 0xB5" level="Op"     property="vTaskEnterCriticalFromISR_Return"               value="uxSavedInterruptStatus=%x[val1]" info=""/>
    <event id="0xF000 + 0xB6" level="API"    property="vTaskExitCritical"                              value="" info=""/>
    <event id="0xF000 + 0xB7" level="Op"     property="vTaskExitCritical_Return"                       value="" info=""/>
    <event id="0xF000 + 0xB8" level="API"    property="vTaskExitCriticalFromISR"                       value="uxSavedInterruptStatus=%x[val1]" info=""/>
    <event id="0xF000 + 0xB9" level="Op"     property="vTaskExitCriticalFromISR_Return"                value="" info=""/>
    <event id="0xF000 + 0xBA" level="API"    property="vTaskListTasks"                                 value="pcWriteBuffer=%x[val1], uxBufferLength=%d[val2]" info=""/>
    <event id="0xF000 + 0xBB" level="Op"     property="vTaskListTasks_Return"                          value="" info=""/>
    <event id="0xF000 + 0xBC" level="API"    property="vTaskGetRunTimeStatistics"                      value="pcWriteBuffer=%x[val1], uxBufferLength=%d[val2]" info=""/>
    <event id="0xF000 + 0xBD" level="Op"     property="vTaskGetRunTimeStatistics_Return"               value="" info=""/>
    <event id="0xF000 + 0xBE" level="API"    property="uxTaskResetEventItemValue"                      value="" info=""/>
    <event id="0xF000 + 0xBF" level="Op"     property="uxTaskResetEventItemValue_Return"               value="uxReturn=%x[val1]" info=""/>
    <event id="0xF000 + 0xC0" level="API"    property="pvTaskIncrementMutexHeldCount"                  value="" info=""/>
    <event id="0xF000 + 0xC1" level="Op"     property="pvTaskIncrementMutexHeldCount_Return"           value="pxTCB=%x[val1]" info=""/>
    <event id="0xF000 + 0xC2" level="API"    property="ulTaskGenericNotifyTake"                        value="uxIndexToWaitOn=%d[val1], xClearCountOnExit=%d[val2], xTicksToWait=%d[val3]" info=""/>
    <event id="0xF000 + 0xC3" level="Op"     property="ulTaskGenericNotifyTake_Return"                 value="" info=""/>
    <event id="0xF000 + 0xC4" level="API"    property="xTaskGenericNotifyWait"                         value="uxIndexToWaitOn=%d[val1], ulBitsToClearOnEntry=%x[val2], ulBitsToClearOnExit=%x[val3]" info=""/>
    <event id="0xF000 + 0xC5" level="API"    property="xTaskGenericNotifyWait"                         value="pulNotificationValue=%x[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF000 + 0xC6" level="Op"     property="xTaskGenericNotifyWait_Return"                  value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xC7" level="API"    property="xTaskGenericNotify"                             value="xTaskToNotify=%x[val1], uxIndexToNotify=%d[val2], ulValue=%x[val3]" info=""/>
    <event id="0xF000 + 0xC8" level="API"    property="xTaskGenericNotify"                             value="eAction=%d[val1], pulPreviousNotificationValue=%x[val2]" info=""/>
    <event id="0xF000 + 0xC9" level="Op"     property="xTaskGenericNotify_Return"                      value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xCA" level="API"    property="xTaskGenericNotifyFromISR"                      value="xTaskToNotify=%x[val1], uxIndexToNotify=%d[val2], ulValue=%x[val3]" info=""/>
    <event id="0xF000 + 0xCB" level="API"    property="xTaskGenericNotifyFromISR"                      value="eAction=%d[val1], pulPreviousNotificationValue=%x[val2], pxHigherPriorityTaskWoken=%x[val3]" info=""/>
    <event id="0xF000 + 0xCC" level="Op"     property="xTaskGenericNotifyFromISR_Return"               value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xCD" level="API"    property="vTaskGenericNotifyGiveFromISR"                  value="xTaskToNotify=%x[val1], uxIndexToNotify=%d[val2], pxHigherPriorityTaskWoken=%x[val3]" info=""/>
    <event id="0xF000 + 0xCE" level="Op"     property="vTaskGenericNotifyGiveFromISR_Return"           value="" info=""/>
    <event id="0xF000 + 0xCF" level="API"    property="xTaskGenericNotifyStateClear"                   value="xTask=%x[val1], uxIndexToClear=%d[val2]" info=""/>
    <event id="0xF000 + 0xD0" level="Op"     property="xTaskGenericNotifyStateClear_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xD1" level="API"    property="ulTaskGenericNotifyValueClear"                  value="xTask=%x[val1], uxIndexToClear=%d[val2], ulBitsToClear=%x[val3]" info=""/>
    <event id="0xF000 + 0xD2" level="Op"     property="ulTaskGenericNotifyValueClear_Return"           value="ulReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xD3" level="API"    property="ulTaskGetRunTimeCounter"                        value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0xD4" level="Op"     property="ulTaskGetRunTimeCounter_Return"                 value="ulRunTimeCounter=%d[val1]" info=""/>
    <event id="0xF000 + 0xD5" level="API"    property="ulTaskGetRunTimePercent"                        value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0xD6" level="Op"     property="ulTaskGetRunTimePercent_Return"                 value="ulReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xD7" level="API"    property="ulTaskGetIdleRunTimeCounter"                    value="" info=""/>
    <event id="0xF000 + 0xD8" level="Op"     property="ulTaskGetIdleRunTimeCounter_Return"             value="ulReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xD9" level="API"    property="ulTaskGetIdleRunTimePercent"                    value="" info=""/>
    <event id="0xF000 + 0xDA" level="Op"     property="ulTaskGetIdleRunTimePercent_Return"             value="ulReturn=%d[val1]" info=""/>
    <event id="0xF000 + 0xDB" level="API"    property="xTaskGetMPUSettings"                            value="xTask=%x[val1]" info=""/>
    <event id="0xF000 + 0xDC" level="Op"     property="xTaskGetMPUSettings_Return"                     value="xMPUSettings=%x[val1]" info=""/>    


    <event id="0xF100 + 0x00" level="Op"    property="QueueCreate"                   value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x01" level="Error" property="QueueCreateFailed"             value="ucQueueType=%x[val1]" info=""/>
    <event id="0xF100 + 0x02" level="Op"    property="CreateMutex"                   value="pxNewQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x03" level="Error" property="CreateMutexFailed"             value="" info=""/>
    <event id="0xF100 + 0x04" level="Op"    property="GiveMutexRecursive"            value="pxMutex=%x[val1]" info=""/>
    <event id="0xF100 + 0x05" level="Error" property="GiveMutexRecursiveFailed"      value="pxMutex=%x[val1]" info=""/>
    <event id="0xF100 + 0x06" level="Op"    property="TakeMutexRecursive"            value="pxMutex=%x[val1]" info=""/>
    <event id="0xF100 + 0x07" level="Error" property="TakeMutexRecursiveFailed"      value="pxMutex=%x[val1]" info=""/>
    <event id="0xF100 + 0x08" level="Op"    property="CreateCountingSemaphore"       value="xHandle=%x[val1]" info=""/>
    <event id="0xF100 + 0x09" level="Error" property="CreateCountingSemaphoreFailed" value="" info=""/>
    <event id="0xF100 + 0x0A" level="Op"    property="QueueSend"                     value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x0B" level="Error" property="QueueSendFailed"               value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x0C" level="Op"    property="QueueReceive"                  value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x0D" level="Op"    property="QueuePeek"                     value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x0E" level="Op"    property="QueuePeekFromIsr"              value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x0F" level="Error" property="QueueReceiveFailed"            value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x10" level="Op"    property="QueueSendFromIsr"              value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x11" level="Error" property="QueueSendFromIsrFailed"        value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x12" level="Op"    property="QueueReceiveFromIsr"           value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x13" level="Error" property="QueueReceiveFromIsrFailed"     value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x14" level="Error" property="QueuePeekFromIsrFailed"        value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x15" level="Op"    property="QueueDelete"                   value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x16" level="Op"    property="QueueRegistryAdd"              value="pxQueue=%x[val1], pcQueueName=%x[val2]" info=""/>
    <event id="0xF100 + 0x17" level="Op"    property="BlockingOnQueueReceive"        value="pxQueue=%x[val1]" info=""/>
    <event id="0xF100 + 0x18" level="Op"    property="BlockingOnQueueSend"           value="pxQueue=%x[val1]" info=""/>


    <event id="0xF200 + 0x00" level="Op"    property="TimerCreate"          value="pxNewTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x01" level="Error" property="TimerCreateFailed"    value="" info=""/>
    <event id="0xF200 + 0x02" level="Op"    property="TimerCommandSend"     value="xTimer=%x[val1], xMessageID=%x[val2], xOptionalValue=%x[val3], xReturn=%x[val4]" info=""/>
    <event id="0xF200 + 0x03" level="Op"    property="TimerCommandReceived" value="xTimer=%x[val1], xMessageID=%x[val2], xOptionalValue=%x[val3]" info=""/>
    <event id="0xF200 + 0x04" level="Op"    property="TimerExpired"         value="pxTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x05" level="Op"    property="PendFuncCall"         value="xFunctionToPend=%x[val1], pvParameter1=%x[val2], ulParameter2=%x[val3], xReturn=%x[val4]" info=""/>
    <event id="0xF200 + 0x06" level="Op"    property="PendFuncCallFromIsr"  value="xFunctionToPend=%x[val1], pvParameter1=%x[val2], ulParameter2=%x[val3], xReturn=%x[val4]" info=""/>
    
    <event id="0xF200 + 0x10" level="API"   property="xTimerCreateTimerTask"                 value="" info=""/>
    <event id="0xF200 + 0x11" level="Op"    property="xTimerCreateTimerTask_Return"          value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x12" level="API"   property="xTimerCreate"                          value="pcTimerName=%x[val1], xTimerPeriodInTicks=%d[val2], xAutoReload=%d[val3]" info=""/>
    <event id="0xF200 + 0x13" level="API"   property="xTimerCreate"                          value="pvTimerID=%x[val1], pxCallbackFunction=%d[val2]" info=""/>
    <event id="0xF200 + 0x14" level="Op"    property="xTimerCreate_Return"                   value="pxNewTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x15" level="API"   property="xTimerCreateStatic"                    value="pcTimerName=%x[val1], xTimerPeriodInTicks=%d[val2], xAutoReload=%d[val3]" info=""/>
    <event id="0xF200 + 0x16" level="API"   property="xTimerCreateStatic"                    value="pvTimerID=%x[val1], pxCallbackFunction=%d[val2], pxTimerBuffer=%x[val3]" info=""/>
    <event id="0xF200 + 0x17" level="Op"    property="xTimerCreateStatic_Return"             value="pxNewTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x18" level="API"   property="xTimerGenericCommandFromTask"          value="xTimer=%x[val1], xCommandID=%d[val2], xOptionalValue=%x[val3]" info=""/>
    <event id="0xF200 + 0x19" level="API"   property="xTimerGenericCommandFromTask"          value="pxHigherPriorityTaskWoken=%x[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF200 + 0x1A" level="Op"    property="xTimerGenericCommandFromTask_Return"   value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x1B" level="API"   property="xTimerGenericCommandFromISR"           value="xTimer=%x[val1], xCommandID=%d[val2], xOptionalValue=%x[val3]" info=""/>
    <event id="0xF200 + 0x1C" level="API"   property="xTimerGenericCommandFromISR"           value="pxHigherPriorityTaskWoken=%x[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF200 + 0x1D" level="Op"    property="xTimerGenericCommandFromISR_Return"    value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x1E" level="API"   property="xTimerGetTimerDaemonTaskHandle"        value="" info=""/>
    <event id="0xF200 + 0x1F" level="Op"    property="xTimerGetTimerDaemonTaskHandle_Return" value="xTimerTaskHandle=%x[val1]" info=""/>
    <event id="0xF200 + 0x20" level="API"   property="xTimerGetPeriod"                       value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x21" level="Op"    property="xTimerGetPeriod_Return"                value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x22" level="API"   property="vTimerSetReloadMode"                   value="xTimer=%x[val1], xAutoReload=%d[val2]" info=""/>
    <event id="0xF200 + 0x23" level="Op"    property="vTimerSetReloadMode_Return"            value="" info=""/>
    <event id="0xF200 + 0x24" level="API"   property="xTimerGetReloadMode"                   value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x25" level="Op"    property="xTimerGetReloadMode_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x26" level="API"   property="uxTimerGetReloadMode"                  value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x27" level="Op"    property="uxTimerGetReloadMode_Return"           value="uxReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x28" level="API"   property="xTimerGetExpiryTime"                   value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x29" level="Op"    property="xTimerGetExpiryTime_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x2A" level="API"   property="xTimerGetStaticBuffer"                 value="xTimer=%x[val1], ppxTimerBuffer=%x[val2]" info=""/>
    <event id="0xF200 + 0x2B" level="Op"    property="xTimerGetStaticBuffer_Return"          value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x2C" level="API"   property="pcTimerGetName"                        value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x2D" level="Op"    property="pcTimerGetName_Return"                 value="pcTimerName=%s[val1]" info=""/>
    <event id="0xF200 + 0x2E" level="API"   property="xTimerIsTimerActive"                   value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x2F" level="Op"    property="xTimerIsTimerActive_Return"            value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x30" level="API"   property="pvTimerGetTimerID"                     value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x31" level="Op"    property="pvTimerGetTimerID_Return"              value="pvReturn=%x[val1]" info=""/>
    <event id="0xF200 + 0x32" level="API"   property="vTimerSetTimerID"                      value="xTimer=%x[val1], pvNewID=%x[val2]" info=""/>
    <event id="0xF200 + 0x33" level="Op"    property="vTimerSetTimerID_Return"               value="" info=""/>
    <event id="0xF200 + 0x34" level="API"   property="xTimerPendFunctionCallFromISR"         value="xFunctionToPend=%x[val1], pvParameter1=%x[val2], ulParameter2=%x[val3], pxHigherPriorityTaskWoken=%x[val4]" info=""/>
    <event id="0xF200 + 0x35" level="Op"    property="xTimerPendFunctionCallFromISR_Return"  value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x36" level="API"   property="xTimerPendFunctionCall"                value="xFunctionToPend=%x[val1], pvParameter1=%x[val2], ulParameter2=%x[val3], xTicksToWait=%d[val4]" info=""/>
    <event id="0xF200 + 0x37" level="Op"    property="xTimerPendFunctionCall_Return"         value="xReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x38" level="API"   property="uxTimerGetTimerNumber"                 value="xTimer=%x[val1]" info=""/>
    <event id="0xF200 + 0x39" level="Op"    property="uxTimerGetTimerNumber_Return"          value="uxReturn=%d[val1]" info=""/>
    <event id="0xF200 + 0x3A" level="API"   property="vTimerSetTimerNumber"                  value="xTimer=%x[val1], uxTimerNumber=%d[val2]" info=""/>
    <event id="0xF200 + 0x3B" level="Op"    property="vTimerSetTimerNumber_Return"           value="" info=""/>


    <event id="0xF300 + 0x00" level="Op"    property="EventGroupCreate"                     value="pxEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x01" level="Error" property="EventGroupCreateFailed"               value="" info=""/>
    <event id="0xF300 + 0x02" level="Op"    property="EventGroupSyncBlock"                  value="pxEventGroup=%x[val1], uxBitsToSet=%x[val2], uxBitsToWaitFor=%x[val3]" info=""/>
    <event id="0xF300 + 0x03" level="Op"    property="EventGroupSyncEnd"                    value="pxEventGroup=%x[val1], uxBitsToSet=%x[val2], uxBitsToWaitFor=%x[val3], xTimeoutOccurred=%x[val4]" info=""/>
    <event id="0xF300 + 0x04" level="Op"    property="EventGroupWaitBitsBlock"              value="pxEventGroup=%x[val1], uxBitsToWaitFor=%x[val2]" info=""/>
    <event id="0xF300 + 0x05" level="Op"    property="EventGroupWaitBitsEnd"                value="pxEventGroup=%x[val1], uxBitsToWaitFor=%x[val2], xTimeoutOccurred=%x[val3]" info=""/>
    <event id="0xF300 + 0x06" level="Op"    property="EventGroupClearBits"                  value="pxEventGroup=%x[val1], uxBitsToClear=%x[val2]" info=""/>
    <event id="0xF300 + 0x07" level="Op"    property="EventGroupClearBitsFromIsr"           value="pxEventGroup=%x[val1], uxBitsToClear=%x[val2]" info=""/>
    <event id="0xF300 + 0x08" level="Op"    property="EventGroupSetBits"                    value="pxEventGroup=%x[val1], uxBitsToSet=%x[val2]" info=""/>
    <event id="0xF300 + 0x09" level="Op"    property="EventGroupSetBitsFromIsr"             value="pxEventGroup=%x[val1], uxBitsToSet=%x[val2]" info=""/>
    <event id="0xF300 + 0x0A" level="Op"    property="EventGroupDelete"                     value="pxEventGroup=%x[val1]" info=""/>

    <event id="0xF300 + 0x10" level="API"   property="xEventGroupCreateStatic"              value="pxEventGroupBuffer=%x[val1]" info=""/>
    <event id="0xF300 + 0x11" level="Op"    property="xEventGroupCreateStatic_Return"       value="xEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x12" level="API"   property="xEventGroupCreate"                    value="" info=""/>
    <event id="0xF300 + 0x13" level="Op"    property="xEventGroupCreate_Return"             value="xEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x14" level="API"   property="xEventGroupSync"                      value="xEventGroup=%x[val1], uxBitsToSet=%x[val2], uxBitsToWaitFor=%x[val3], xTicksToWait=%d[val4]" info=""/>
    <event id="0xF300 + 0x15" level="Op"    property="xEventGroupSync_Return"               value="uxReturn=%x[val1]" info=""/>
    <event id="0xF300 + 0x16" level="API"   property="xEventGroupWaitBits"                  value="xEventGroup=%x[val1], uxBitsToWaitFor=%x[val2], xClearOnExit=%x[val3]" info=""/>
    <event id="0xF300 + 0x17" level="API"   property="xEventGroupWaitBits"                  value="xWaitForAllBits=%d[val1], xTicksToWait=%d[val2]" info=""/>
    <event id="0xF300 + 0x18" level="Op"    property="xEventGroupWaitBits_Return"           value="uxReturn=%x[val1]" info=""/>
    <event id="0xF300 + 0x19" level="API"   property="xEventGroupClearBits"                 value="xEventGroup=%x[val1], uxBitsToClear=%x[val2]" info=""/>
    <event id="0xF300 + 0x1A" level="Op"    property="xEventGroupClearBits_Return"          value="uxReturn=%x[val1]" info=""/>
    <event id="0xF300 + 0x1B" level="API"   property="xEventGroupClearBitsFromISR"          value="xEventGroup=%x[val1], uxBitsToClear=%x[val2]" info=""/>
    <event id="0xF300 + 0x1C" level="Op"    property="xEventGroupClearBitsFromISR_Return"   value="xReturn=%d[val1]" info=""/>
    <event id="0xF300 + 0x1D" level="API"   property="xEventGroupGetBitsFromISR"            value="xEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x1E" level="Op"    property="xEventGroupGetBitsFromISR_Return"     value="uxReturn=%x[val1]" info=""/>
    <event id="0xF300 + 0x1F" level="API"   property="xEventGroupSetBits"                   value="xEventGroup=%x[val1], uxBitsToSet=%x[val2]" info=""/>
    <event id="0xF300 + 0x20" level="Op"    property="xEventGroupSetBits_Return"            value="uxReturn=%x[val1]" info=""/>
    <event id="0xF300 + 0x21" level="API"   property="vEventGroupDelete"                    value="xEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x22" level="Op"    property="vEventGroupDelete_Return"             value="" info=""/>
    <event id="0xF300 + 0x23" level="API"   property="xEventGroupGetStaticBuffer"           value="xEventGroup=%x[val1], ppxEventGroupBuffer=%x[val2]" info=""/>
    <event id="0xF300 + 0x24" level="Op"    property="xEventGroupGetStaticBuffer_Return"    value="xReturn=%d[val1]" info=""/>
    <event id="0xF300 + 0x25" level="API"   property="vEventGroupSetBitsCallback"           value="pvEventGroup=%x[val1], ulBitsToSet=%x[val2]" info=""/>
    <event id="0xF300 + 0x26" level="Op"    property="vEventGroupSetBitsCallback_Return"    value="" info=""/>
    <event id="0xF300 + 0x27" level="API"   property="vEventGroupClearBitsCallback"         value="pvEventGroup=%x[val1], ulBitsToClear=%x[val2]" info=""/>
    <event id="0xF300 + 0x28" level="Op"    property="vEventGroupClearBitsCallback_Return"  value="" info=""/>
    <event id="0xF300 + 0x29" level="API"   property="xEventGroupSetBitsFromISR"            value="xEventGroup=%x[val1], uxBitsToSet=%x[val2], pxHigherPriorityTaskWoken=%x[val3]" info=""/>
    <event id="0xF300 + 0x2A" level="Op"    property="xEventGroupSetBitsFromISR_Return"     value="xReturn=%d[val1]" info=""/>
    <event id="0xF300 + 0x2B" level="API"   property="uxEventGroupGetNumber"                value="xEventGroup=%x[val1]" info=""/>
    <event id="0xF300 + 0x2C" level="Op"    property="uxEventGroupGetNumber_Return"         value="xReturn=%d[val1]" info=""/>
    <event id="0xF300 + 0x2D" level="API"   property="vEventGroupSetNumber"                 value="xEventGroup=%x[val1], uxEventGroupNumber=%d[val2]" info=""/>
    <event id="0xF300 + 0x2E" level="Op"    property="vEventGroupSetNumber_Return"          value="" info=""/>


    <event id="0xF400 + 0x00" level="Op"    property="Malloc" value="pvAddress=%x[val1], uiSize=%d[val2]" info=""/>
    <event id="0xF400 + 0x01" level="Op"    property="Free"   value="pvAddress=%x[val1], uiSize=%d[val2]" info=""/>


    <event id="0xF500 + 0x00" level="Error" property="StreamBufferCreateFailed"       value="uxIsMessageBuffer=%d[val1]" info=""/>
    <event id="0xF500 + 0x01" level="Error" property="StreamBufferCreateStaticFailed" value="pxStreamBuffer=%x[val1], uxIsMessageBuffer=%d[val2]" info=""/>
    <event id="0xF500 + 0x02" level="Op"    property="StreamBufferCreate"             value="pxStreamBuffer=%x[val1], uxIsMessageBuffer=%d[val2]" info=""/>
    <event id="0xF500 + 0x03" level="Op"    property="StreamBufferDelete"             value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x04" level="Op"    property="StreamBufferReset"              value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x05" level="Op"    property="StreamBufferBlockingOnSend"     value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x06" level="Op"    property="StreamBufferSend"               value="pxStreamBuffer=%x[val1], xBytesSent=%d[val2]" info=""/>
    <event id="0xF500 + 0x07" level="Error" property="StreamBufferSendFailed"         value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x08" level="Op"    property="StreamBufferSendFromIsr"        value="pxStreamBuffer=%x[val1], xBytesSent=%d[val2]" info=""/>
    <event id="0xF500 + 0x09" level="Op"    property="StreamBufferBlockingOnReceive"  value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x0A" level="Op"    property="StreamBufferReceive"            value="pxStreamBuffer=%x[val1], xReceivedLength=%d[val2]" info=""/>
    <event id="0xF500 + 0x0B" level="Error" property="StreamBufferReceiveFailed"      value="pxStreamBuffer=%x[val1]" info=""/>
    <event id="0xF500 + 0x0C" level="Op"    property="StreamBufferReceiveFromIsr"     value="pxStreamBuffer=%x[val1], xReceivedLength=%d[val2]" info=""/>

  </events>

</component_viewer>
